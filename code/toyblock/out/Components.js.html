<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Components.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Components.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { Component } from 'react'
import { Transaction, Notebook, Village } from './Classes.js'

// Visual imports

import chatVisual from './visuals/Chat.png';
import grenouilleVisual from './visuals/Grenouille.png'
import paresseuxVisual from './visuals/Paresseux.png'
import pingouinVisual from './visuals/Pingouin.png'
import singeVisual from './visuals/Singe.png'
import toucanVisual from './visuals/Toucan.png'
import flechVisual from './visuals/flech.png'
import chatmaison from './visuals/chatmaison.png'
import grenouillemaison from './visuals/grenouillemaison.png'
import singemaison from './visuals/singemaison.png'
import pingouinmaison from './visuals/pingouinmaison.png'
import paresseuxmaison from './visuals/paresseuxmaison.png'
import toucanmaison from './visuals/toucanmaison.png'
import lettre from './visuals/lettre.png'

// TODO Corriger les erreurs js

// TODO Ajouter les derniers dessins

// Constants definition

// Here you can change the members of the story.
// Note: The current version of the project won't visually handle modification of these data. 
// The Village Notebook and Transaction class will still work perfectly.

const animals = ["Paresseux", "Pingouin", "Toucan", "Grenouille", "Singe", "Chat"]
const neighbors = { "Paresseux": { "Toucan": 2, "Grenouille": 2 }, "Pingouin": { "Grenouille": 1 }, "Toucan": { "Paresseux": 2, "Chat": 1 }, "Grenouille": { "Paresseux": 2, "Singe": 1, "Pingouin": 1 }, "Singe": { "Grenouille": 1 }, "Chat": { "Toucan": 1 } }
const visualMapping = { "Chat": chatVisual, "Grenouille": grenouilleVisual, "Paresseux": paresseuxVisual, "Pingouin": pingouinVisual, "Singe": singeVisual, "Toucan": toucanVisual }
const positions = { "Singe": [1, 1], "Grenouille": [1, 2], "Pingouin": [1, 3], "Paresseux": [2, 2], "Toucan": [3, 2], "Chat": [3, 3] };

/**
 * Returns the image file associated with the villager
 * 
 * @param {string} animal - The name of the villager
 * @returns {Object} - The visual corresponding to the villager
 */
function findVisual(animal) {
        return visualMapping[animal]
}

/**
 * Display an animated letter on DOM depending on the origin and destination
 * 
 * @param {string} from - The villager the transaction comes from
 * @param {string} to - The villager the transaction goes to
 */
function sendLetter(from, to) {

        // Defines which movement we will need
        let movementclass = ""
        let x_movement = positions[to][0] - positions[from][0];
        let y_movement = positions[to][1] - positions[from][1];

        // Assertions
        console.assert(x_movement &lt;= 1 &amp;&amp; x_movement >= -1, "x should be between -1 and 1")
        console.assert(y_movement &lt;= 1 &amp;&amp; y_movement >= -1, "y should be between -1 and 1")
        console.assert((y_movement == 0 &amp;&amp; x_movement != 0)||(y_movement != 0 &amp;&amp; x_movement == 0), "x and y can't equal or be different of 0 at the same time")

        // Associate each movement with a name
        if (x_movement == 1) {
                movementclass = "-left-right"
        }
        if (x_movement == -1) {
                movementclass = "-right-left"
        }
        if (y_movement == 1) {
                movementclass = "-up-down"
        }
        if (y_movement == -1) {
                movementclass = "-down-up"
        }

        // Add a new element to DOM
        var newElement = document.createElement("img");

        newElement.src = lettre;
        newElement.width = "120"
        newElement.height = "120"
        newElement.className = from + "letter" + movementclass + " letter"

        document.getElementById("villageContainer").appendChild(newElement);
}

////////////////////////////////////////////////////////
// React components                                   //
////////////////////////////////////////////////////////

/*
 index={index}
 from={this.state.transactions[index].getFrom()}
 to={this.state.transactions[index].getTo()}
 amount={this.state.transactions[index].getAmount()}
 validated={this.state.transactions[index].isValidated()}
 validable={this.state.validable[index]}
 validateTransaction={this.validateTransaction}
 handleChangeAmount={this.handleChangeAmount}
 generateNextVillager={this.generateNextVillager}
 moneyName={this.props.moneyName}
 */
 // Since React components structure is different I 
 /*


 */
/**
 * Component displaying a transaction line
 */
class TransactionLine extends Component {
        /**
         * Display a transaction line
         * 
         * @param {number} index - The index of the transaction
         * @param {string} from - The villager who gives the money
         * @param {string} to - The villager who receives the money
         * @param {number} amount - The amount of money spent
         * @param {boolean} validated - Whether or not the transaction is validated
         * @param {boolean} validable - Whether or not the transaction can be validated
         * @param {string} moneyName - The name of the money
         * 
         * @param {function} [validateTransaction] - Passed by the notebook component
         * @param {function} [handleChangeAmount] - Passed  by notebook component
         * @param {function} [generateNextVillager] - Passed by the notebook component
         */
        constructor(props) {
                super(props);
                this.validateTransaction = this.validateTransaction.bind(this);
                this.handleChangeAmount = this.handleChangeAmount.bind(this);
                this.generateNextVillager = this.generateNextVillager.bind(this);
        }

        /**
         * Update the amount of the transaction
         * 
         * @param {event} e - The value of the input box
         */
        handleChangeAmount(e) {
                // Prevent empty entries
                let value = 0
                if (e.target.value != '') {
                        value = parseInt(e.target.value)
                }

                this.props.handleChangeAmount(this.props.index, value)

        }

        /**
         * Validate the transaction
         */
        validateTransaction() {
                this.props.validateTransaction(this.props.index)
        }

        /**
         * Change the current to and from properties depending on the available villagers.
         * 
         * @param {string} fromto - Whether the origin villager or the destination villager needs to change
         */
        generateNextVillager(fromto) {

                this.props.generateNextVillager(this.props.index, fromto)

        }

        /**
         * Debug function
         * @param {event} e 
         */
        check = (e) => {
        }

        /**
         * Defines the displaying of the transaction
         * 
         * @returns {html} - The displaying of the transaction
         */
        render() {
                let fulltext = []

                let fromWidth = "80"
                if (this.props.from == "Toucan" || this.props.from == "Singe") {
                        fromWidth = "120"
                }

                let toWidth = "80"
                if (this.props.to == "Toucan" || this.props.to == "Singe") {
                        toWidth = "120"
                }

                if (!(this.props.validated)) {
                        // Transaction non validées non validables
                        if (!(this.props.validable)) {
                                fulltext.push(
                                        &lt;div class="noWrap">
                                                &lt;div class="spriteWrapper">
                                                        &lt;img onClick={() => this.generateNextVillager("From")} src={findVisual(this.props.from)} class="villagerSprite clickable" height="80" width={fromWidth}>&lt;/img>
                                                &lt;/div>
                                                &lt;img src={flechVisual} height="80" width="120">&lt;/img>
                                                &lt;div class="spriteWrapper">
                                                        &lt;img onClick={() => this.generateNextVillager("To")} src={findVisual(this.props.to)} class="villagerSprite clickable" height="80" width={toWidth}>&lt;/img>
                                                &lt;/div>
                                                &lt;div class="displayAmount">
                                                        &lt;input class="amountForm" type="number" value={this.props.amount} onChange={this.handleChangeAmount} />
                                                        {this.props.moneyName}s
                                                &lt;/div>
                                                &lt;div class="validateWrapper">&lt;/div>

                                        &lt;/div>
                                )
                        }
                        // Transactions non validées validables
                        else {
                                fulltext.push(
                                        &lt;div class="noWrap">
                                                &lt;div class="spriteWrapper">
                                                        &lt;img onClick={() => this.generateNextVillager("From")} src={findVisual(this.props.from)} class="villagerSprite clickable" height="80" width={fromWidth}>&lt;/img>
                                                &lt;/div>
                                                &lt;img src={flechVisual} height="80" width="120">&lt;/img>
                                                &lt;div class="spriteWrapper">
                                                        &lt;img onClick={() => this.generateNextVillager("To")} src={findVisual(this.props.to)} class="villagerSprite clickable" height="80" width={toWidth}>&lt;/img>
                                                &lt;/div>
                                                &lt;div class="displayAmount">
                                                        &lt;input class="amountForm" type="number" value={this.props.amount} onChange={this.handleChangeAmount} />
                                                        {this.props.moneyName}s
                                                &lt;/div>
                                                &lt;div class="validateWrapper">

                                                        &lt;button class="button" onClick={() => this.validateTransaction()}>
                                                                &lt;div>
                                                                        Valider
                                                                &lt;/div>
                                                        &lt;/button>


                                                &lt;/div>
                                        &lt;/div>)
                        }

                }

                // Transactions validées
                else {
                        fulltext.push(
                                &lt;div class="noWrap">
                                        &lt;div class="spriteWrapper">&lt;img src={findVisual(this.props.from)} class="villagerSprite" height="80" width={fromWidth}>&lt;/img>&lt;/div>
                                        &lt;div>&lt;img src={flechVisual} height="80" width="120">&lt;/img>&lt;/div>
                                        &lt;div class="spriteWrapper">&lt;img src={findVisual(this.props.to)} class="villagerSprite" height="80" width={toWidth}>&lt;/img>&lt;/div>
                                        &lt;div class="displayAmount">&lt;div class="amountForm">{this.props.amount}&lt;/div> &lt;div>{this.props.moneyName}s&lt;/div>&lt;/div>
                                        &lt;div class="validateWrapper">&lt;/div>
                                &lt;/div>
                        )
                }

                return fulltext;
        }
}


// Component displaying a transaction list


// TODO Finir la spec des props
/*
Waited props:

notebook : the notebook object you want to display
limit : the 
resettable = {false}
inVillage : set to true if you call this component from a VillageBlock component
transmitTransaction = a transmission function from a VillageBlock component (don't need to pass it if you're not calling from a VillageBlock)
moneyName : 
*/
/**
 * 
 */
class NotebookBlock extends Component {
        constructor(props) {
                super(props);

                let availableVillagers = []
                for (let index = 0; index &lt; this.props.notebook.getTransactions().length; index++) {
                        let newArray = [...this.props.notebook.getVillagers()];
                        newArray.splice(newArray.lastIndexOf(this.props.notebook.getTransactions()[index].getFrom()), 1);
                        newArray.splice(newArray.lastIndexOf(this.props.notebook.getTransactions()[index].getTo()), 1);
                        availableVillagers.push(newArray)
                }

                this.state = {
                        notebook: this.props.notebook,
                        transactions: this.props.notebook.getTransactions(),
                        villagers: this.props.notebook.getVillagers(),
                        availableVillagers: availableVillagers,
                        validable: []
                }

                this.transmitTransaction = this.transmitTransaction.bind(this)
                this.validateTransaction = this.validateTransaction.bind(this);
                this.handleChangeAmount = this.handleChangeAmount.bind(this);
                this.generateNextVillager = this.generateNextVillager.bind(this);

                this.updateValidable();
        }

        // Debug helper
        // Will display in the console the current state of the memory
        check() {
                console.log("===================================================")
                console.log("Les transactions actuelles")
                console.log(this.state.transactions)
                console.log("L'objet Notebook en props")
                console.log(this.props.notebook)
                console.log("L'objet Notebook en state")
                console.log(this.state.notebook)
                console.log("Les villageois disponibles pour chaque transaction")
                console.log(this.state.availableVillagers)
                console.log("Quelle transaction est validable ?")
                console.log(this.state.validable)
                // Add instructions here
        }

        // Debug helper
        // Useful to trigger some functions
        clickMe() {
                console.log("touchMe triggered")
                // Add functions here
        }

        validateTransaction(index) {
                let newtransactions = this.state.transactions
                console.log("Transaction validated")
                newtransactions[index].validate();

                let newnotebook = this.state.notebook
                newnotebook.applyTransaction(newtransactions[index])

                // S'il reste assez de place, crée une nouvelle transaction vide
                let newavailable = [...this.state.availableVillagers]

                if (this.state.transactions.length &lt; this.props.limit) {
                        newnotebook.addTransaction(new Transaction(newtransactions[index].getFrom(), newtransactions[index].getTo(), 0, false))
                        newavailable.push(this.state.availableVillagers[index])
                }

                // Si y a des voisins, leur envoie une copie de la transaction
                if (this.props.inVillage) {
                        this.transmitTransaction(newtransactions[index], "")
                }

                // Update l'affichage

                this.setState({ transaction: newtransactions, notebook: newnotebook, availableVillagers: newavailable });
                this.updateValidable()
        }

        transmitTransaction(transaction, exclude) {
                if (this.props.inVillage) {
                        this.props.transmitTransaction(this.state.notebook.property, transaction, exclude)
                }
        }

        handleChangeAmount(index, newAmount) {
                let newtransactions = this.state.transactions
                newtransactions[index].setAmount(newAmount);

                // Update l'affichage

                this.setState({ transaction: newtransactions });
                this.updateValidable()
        }

        generateNextVillager(id, fromto) {

                let tempTransactions = this.state.transactions
                let totalArr = [...this.state.availableVillagers]

                let assertionBuddy = 0


                if (fromto == "From") {
                        let arr = [...this.state.availableVillagers][id];
                        arr.push(this.state.transactions[id].getFrom())
                        let newFrom = arr[0]
                        arr.shift()
                        tempTransactions[id].setFrom(newFrom)
                        totalArr[id] = arr

                        assertionBuddy++
                }

                if (fromto == "To") {
                        let arr = [...this.state.availableVillagers][id];
                        arr.push(this.state.transactions[id].getTo())
                        let newTo = arr[0]
                        arr.shift()
                        tempTransactions[id].setTo(newTo)
                        totalArr[id] = arr

                        assertionBuddy++
                }

                console.assert(assertionBuddy == 1, "Incorrect fromTo parameter")

                // Update l'affichage

                this.setState({ availableVillagers: totalArr, transaction: tempTransactions })
                this.updateValidable()
        }

        updateValidable() {
                let temp = [...this.state.transactions];
                let newValidable = []

                for (let i = 0; i &lt; temp.length; i++) {
                        newValidable.push(true)
                        if ((temp[i].isValidated()) || (isNaN(temp[i].getAmount()) || (temp[i].getAmount() &lt;= 0))) {
                                newValidable[i] = false
                        }
                        else {
                                if (this.state.notebook.checkAccount(temp[i])) {
                                        newValidable[i] = true;
                                }
                                else {
                                        newValidable[i] = false;
                                }
                        }
                }

                // Update l'affichage

                this.setState({ validable: newValidable })
        }

        // reset the notebook block with a brand new empty notebook
        fullReset() {

                let notebook = new Notebook(this.state.notebook.getProperty(), this.state.notebook.getStartMoney(), this.state.notebook.getVillagers(), false)
                notebook.addTransaction(new Transaction(
                        this.state.transactions[this.state.transactions.length - 1].getFrom(),
                        this.state.transactions[this.state.transactions.length - 1].getTo(),
                        0,
                        false
                )
                )
                let transactions = notebook.getTransactions()
                let villagers = notebook.getVillagers()
                let availableVillagers = []
                availableVillagers.push(this.state.availableVillagers[this.state.availableVillagers.length - 1])
                let validable = []
                validable.push(false)

                this.setState({
                        notebook: notebook,
                        transactions: transactions,
                        villagers: villagers,
                        availableVillagers: availableVillagers,
                        validable: validable
                })

                this.updateValidable();
        }

        // TODO Comment gérer une transaction qui entre alors que c'est complet ?

        render() {
                let fullRender = []

                for (let index = 0; index &lt; this.state.transactions.length; index++) {
                        fullRender.push(
                                &lt;div class="transactionLine">
                                        &lt;div key={index} class="inline">
                                                &lt;TransactionLine
                                                        index={index}
                                                        from={this.state.transactions[index].getFrom()}
                                                        to={this.state.transactions[index].getTo()}
                                                        amount={this.state.transactions[index].getAmount()}
                                                        validated={this.state.transactions[index].isValidated()}
                                                        validable={this.state.validable[index]}
                                                        validateTransaction={this.validateTransaction}
                                                        handleChangeAmount={this.handleChangeAmount}
                                                        generateNextVillager={this.generateNextVillager}
                                                        moneyName={this.props.moneyName}
                                                />
                                        &lt;/div>&lt;/div>)
                }

                // If the component is resettable add a reset button
                if (this.props.resettable) {
                        fullRender.push(
                                &lt;button onClick={() => this.fullReset()} class="button">
                                        Reset
                                &lt;/button>
                        )
                }

                // Debug buttons
                if (this.props.testing) {
                        fullRender.push(
                                &lt;div>
                                        &lt;button onClick={() => this.check()}>
                                                Vérifier l'état du notebook
                                        &lt;/button>
                                        &lt;button onClick={() => this.clickMe()}>
                                                Bouton de test
                                        &lt;/button>
                                &lt;/div>
                        )
                }

                return (
                        &lt;div>
                                {fullRender}
                        &lt;/div>
                )
        }

}

//Component displaying a village

/*
Waited props:

village : village object you want to display (village)
limit : the number of transactions a notebook can handle (integer)
resettable : if the village can be resetted (boolean)
moneyName : 

*/
class VillageBlock extends Component {
        constructor(props) {
                super(props);

                let village = new Village(this.props.basemoney, this.props.animals, this.props.neighbors, this.props.fillEmptyTransaction);
                this.state = {
                        startMoney: village.getStartMoney(),
                        village: village,
                        invalidNotebook: false,
                        selectedVillager: ""
                }

                this.transmitTransaction = this.transmitTransaction.bind(this)
        }

        clickMe(e) {

                // Add functions here

        }

        transmitTransaction(property, transaction, exclude) {
                this.state.village.getNotebook(property).transmitTransaction(transaction, exclude)
                this.setState({ village: this.state.village })
                setTimeout(() => { this.setState({}) }, 9000);
                setTimeout(() => { this.alertInvalidNotebook() }, 9000);
                setTimeout(() => { this.setState({}) }, 18000);
                setTimeout(() => { this.alertInvalidNotebook() }, 18000);
                setTimeout(() => { this.setState({}) }, 27000);
                setTimeout(() => { this.alertInvalidNotebook() }, 27000);
                setTimeout(() => { this.setState({}) }, 36000);
                setTimeout(() => { this.alertInvalidNotebook() }, 36000);
        }

        alertInvalidNotebook() {
                if (!(this.state.invalidNotebook)) {
                        for (let index in this.state.village.getNotebooks()) {
                                if (this.state.village.getNotebooks()[index].isNotebookInvalid()) {
                                        this.setState({ invalidNotebook: true })
                                }
                        }
                }
        }

        fullReset() {

                this.state.village.setObsolete();

                let newVillage = new Village(this.props.basemoney, this.props.animals, this.props.neighbors, this.props.fillEmptyTransaction);
                this.setState({
                        startMoney: newVillage.getStartMoney(),
                        village: newVillage,
                        invalidNotebook: false,
                        selectedVillager: ""
                })

                const letters = document.getElementsByClassName('letter');
                while (letters.length > 0) letters[0].remove();

        }

        //TODO Faire en sorte que ça s'ajoute pas en dernière place

        check(e) {
                console.log("===================================================")
                console.log("Etat du village en state")
                console.log(this.state.village)
                console.log("Etat du clone du village")
                console.log(this.state.cloneVillage)
                console.log("Villageois sélectionné")
                console.log(this.state.selectedVillager)
        }

        selectVillager(animal) {
                if (this.state.selectedVillager == animal) {
                        this.setState({ selectedVillager: "" })
                }
                else {
                        this.setState({ selectedVillager: animal })
                }
        }

        render() {
                var fulltext = []

                let valid = true;

                for (let index in this.state.village.getNotebooks()) {
                        if (this.state.village.getNotebooks()[index].isNotebookInvalid()) {
                                valid = false;
                        }
                }

                // D'abord, affiche le village

                if (valid) {
                        fulltext.push(&lt;div id="villageContainer" class="villageContainer">
                                &lt;div id="h-l-pathway">&lt;/div>
                                &lt;div id="v-l-pathway">&lt;/div>
                                &lt;div id="v-s-pathway">&lt;/div>
                                &lt;img src={singemaison} onClick={() => this.selectVillager("Singe")} id="singevillager" class="clickable" width="120" height="120">&lt;/img>
                                &lt;img src={grenouillemaison} onClick={() => this.selectVillager("Grenouille")} id="grenouillevillager" class="clickable" width="120" height="120">&lt;/img>
                                &lt;img src={pingouinmaison} onClick={() => this.selectVillager("Pingouin")} id="pingouinvillager" class="clickable" width="120" height="120">&lt;/img>
                                &lt;img src={paresseuxmaison} onClick={() => this.selectVillager("Paresseux")} id="paresseuxvillager" class="clickable" width="120" height="120">&lt;/img>
                                &lt;img src={toucanmaison} onClick={() => this.selectVillager("Toucan")} id="toucanvillager" class="clickable" width="120" height="120">&lt;/img>
                                &lt;img src={chatmaison} onClick={() => this.selectVillager("Chat")} id="chatvillager" class="clickable" width="120" height="120">&lt;/img>
                                &lt;button id="buttonResetVillage" class="button" onClick={() => this.fullReset()}> Reset &lt;/button>
                        &lt;/div>)
                }
                else {
                        fulltext.push(&lt;div id="villageContainer" class="villageContainer">
                                &lt;div id="h-l-pathway">&lt;/div>
                                &lt;div id="v-l-pathway">&lt;/div>
                                &lt;div id="v-s-pathway">&lt;/div>
                                &lt;img src={singemaison} id="singevillager" width="120" height="120">&lt;/img>
                                &lt;img src={grenouillemaison} id="grenouillevillager" width="120" height="120">&lt;/img>
                                &lt;img src={pingouinmaison} id="pingouinvillager" width="120" height="120">&lt;/img>
                                &lt;img src={paresseuxmaison} id="paresseuxvillager" width="120" height="120">&lt;/img>
                                &lt;img src={toucanmaison} id="toucanvillager" width="120" height="120">&lt;/img>
                                &lt;img src={chatmaison} id="chatvillager" width="120" height="120">&lt;/img>
                                &lt;button id="buttonResetVillage" class="button" onClick={() => this.fullReset()}> Reset &lt;/button>
                        &lt;/div>)
                }


                // Si un notebook est sélectionné, l'affiche en dessous

                if (valid) {
                        for (let index in this.state.village.getNotebooks()) {
                                if (this.state.village.getNotebooks()[index].getProperty() == this.state.selectedVillager) {
                                        fulltext.push(&lt;div key={index}>
                                                {this.state.village.getNotebooks()[index].getProperty()}
                                                &lt;NotebookBlock
                                                        notebook={this.state.village.getNotebooks()[index]}
                                                        limit={this.props.limit}
                                                        resettable={false}
                                                        inVillage={true}
                                                        transmitTransaction={this.transmitTransaction}
                                                        moneyName={this.props.moneyName}
                                                />
                                        &lt;/div>
                                        )
                                }
                        }
                }

                if (this.props.testing) {
                        fulltext.push(
                                &lt;div>
                                        &lt;button onClick={() => this.clickMe()}>
                                                Bouton de test
                                        &lt;/button>
                                        &lt;button onClick={() => this.check()}>
                                                Vérifier état
                                        &lt;/button>
                                &lt;/div>
                        )
                }

                return (
                        &lt;ul>
                                {fulltext}
                        &lt;/ul>
                )
        }

}

////////////////////////////////////////////////////////

// Hashing machine

const SHA256 = require("crypto-js/sha256");

function hashing(number) {
        return SHA256(number).toString()
}

class HashingBlock extends Component {
        constructor(props) {
                super(props);
                this.state = { hashword: this.props.baseword, hashed: hashing(this.props.baseword) }
        }

        handleChange = (e) => {
                this.setState({ hashword: (e.target.value) })
                this.setState({ hashed: hashing(e.target.value) })
        }

        render() {
                return (
                        &lt;div className="centeredtext">

                                &lt;input type="text" value={this.state.hashword} onChange={this.handleChange} class="input" />

                                &lt;div class="centeredelement">
                                        &lt;div class="output">
                                                {this.state.hashed}
                                        &lt;/div>
                                &lt;/div>
                        &lt;/div>
                )
        }
}

export {
        hashing, sendLetter,
        TransactionLine, NotebookBlock, VillageBlock, HashingBlock,
        animals, neighbors
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Notebook.html">Notebook</a></li><li><a href="NotebookBlock.html">NotebookBlock</a></li><li><a href="Transaction.html">Transaction</a></li><li><a href="TransactionLine.html">TransactionLine</a></li><li><a href="Village.html">Village</a></li></ul><h3>Global</h3><ul><li><a href="global.html#findVisual">findVisual</a></li><li><a href="global.html#sendLetter">sendLetter</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Sun Mar 06 2022 21:26:22 GMT+0100 (heure normale d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
